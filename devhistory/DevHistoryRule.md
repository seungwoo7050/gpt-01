## 프로젝트 목표 및 작업 가이드라인 (Project Goal & Working Guidelines)

**1. 핵심 목표 (Core Objective):**
이 프로젝트의 최종 목표는 `cpp-multiplayer-game-server` 프로젝트의 전체 개발 역사를 단계별로 완벽하게 재구현할 수 있도록, 상세하고 포괄적인 `DevHistory` 문서 시리즈를 작성하는 것입니다. 각 문서는 독립적으로 이해 가능해야 하며, 제3자가 해당 MVP를 재현하는 데 필요한 모든 정보를 담고 있어야 합니다.

**2. 진실의 원천 (Single Source of Truth):**
*   `src` 디렉토리의 소스 코드가 **현재 상태의 유일한 진실의 원천**입니다.
*   `DevHistoryXX.md` 문서는 각 MVP 단계의 **설계 명세** 역할을 하며, 코드와 100% 동기화되어야 합니다.
*   `docs/development/DEVELOPMENT_JOURNEY.md` 파일은 개발 타임라인과 각 MVP의 개괄적인 범위를 참고하기 위한 용도로만 사용합니다.

**3. 시퀀스 번호 부여 원칙 (Sequence Numbering Principles):**
*   **유일성 (Uniqueness):** 특정 MVP 내의 모든 시퀀스 번호는 유일해야 합니다. (예: `MVP4-21`은 MVP4 내에서 단 한 번만 사용될 수 있습니다.) 중복이 발견될 경우, 계획을 수립하여 유일한 번호로 재정렬합니다.
*   **역사성 (Historicity):** 기능이 여러 MVP에 걸쳐 수정될 때, 기존의 숫자 기반 시퀀스 주석(`// [SEQUENCE: 123]`)은 새로운 MVP 시퀀스 주석으로 대체(제거 후 추가)합니다. 하지만, 한번 작성된 **MVP 기반 시퀀스 주석(`// [SEQUENCE: MVPX-Y]`)은 수정하거나 삭제하지 않습니다.** 대신, 해당 기능에 대한 후속 MVP의 변경 사항이 생기면, 관련된 **새로운 MVP 시퀀스 주석을 기존 주석 아래에 추가**합니다. 이를 통해 코드의 변경 이력이 MVP 단위로 남게 됩니다.

**4. 핵심 작업 절차 (Core Workflow - 각 MVP에 반복):**
1.  **상세 설명 원칙 (Detailed Explanation Principle):** 각 `DevHistory` 문서 작성 시, 단순히 시퀀스 목록을 나열하는 것을 넘어, 해당 MVP의 핵심 기능들에 대한 **설계 목표, 기술적 선택 이유, 그리고 기대 효과 등을 설명하는 개요 단락을 반드시 포함**해야 합니다. 이는 코드의 '무엇'을 넘어 '왜'를 설명하기 위함입니다.
2.  **문서 검토 (Review Document):** 해당 MVP의 `DevHistoryXX.md` 파일을 읽고, 명시된 시퀀스 번호와 파일 목록을 파악합니다. 문서 자체의 논리적 오류(번호 중복 등)를 먼저 확인합니다.
3.  **코드 검증 (Verify Code):** `grep`을 사용하여 `src` 디렉토리 내에 해당 MVP의 시퀀스 번호가 문서와 일치하게 존재하는지 확인합니다.
4.  **불일치 해결 계획 수립 (Plan Discrepancy Resolution):** 문서와 코드 간의 불일치(누락, 중복, 오류)가 발견되면, 이를 해결하기 위한 **종합적인 계획을 먼저 수립하여 사용자에게 제시하고 승인**을 받습니다. 여기에는 시퀀스 번호 재정렬, 누락된 파일 내용 추가 등이 포함될 수 있습니다.
5.  **계획 실행 (Execute Plan):** 승인된 계획에 따라, 코드(`src`)와 문서(`DevHistoryXX.md`)를 모두 수정하여 동기화합니다.
6.  **문서-코드 주석 일치 (Comment Synchronization):** `DevHistory` 문서에 포함되는 모든 시퀀스 주석은, 대응하는 소스 코드의 주석과 **글자 하나까지 정확히 일치**해야 합니다. 범위 요약(`A~B`)은 허용되지 않습니다.
7.  **전체 내용 보존 (Preserve Full Content):** 파일 수정 시, 특정 부분만 변경하더라도 나머지 내용이 절대 유실되지 않도록 항상 **전체 내용을 보존하여 작업**합니다.

**5. 코드 수정 원칙 (Code Modification Principles):**
*   **코드 생성 (Code Generation):** 문서화 과정에서 MVP 기능 구현에 필요한 소스 파일(`.h` 또는 `.cpp`)이 없는 경우, **새로운 파일을 직접 생성하는 것은 허용됩니다.**
*   **코드 보존 (Code Preservation):** 기존 코드를 수정하거나 리팩토링하는 것은 허용되지만, **기능하는 기존 코드를 삭제하는 것은 절대 금지됩니다.** 파일의 목적이 더 이상 유효하지 않다면, 명시적인 확인 없이 내용을 삭제하지 말고 사용 중단(deprecation)으로 표시하십시오.
*   **진실의 원천 (백업) (Source of Truth (Backup)):** 파일 손상 또는 의도치 않은 삭제 시, 읽기 전용 백업 디렉토리 (`/home/woopinbells/Desktop/tmp-git-origin/clear-claude-prompt/use-portfolio/cpp-multiplayer-game-server`)를 최종적인 복원 소스로 사용해야 합니다.

**6. 세션 재개 프로토콜 (Session Resumption Protocol):**
작업이 중단된 후 새로운 세션에서 재개할 경우, 다음 절차를 반드시 따르십시오.
1.  **목표 식별 (Identify Goal):** 사용자의 프롬프트(예: "DevHistoryRule.md문서를 읽고 X버전부터 작업을 이어나가세요.")를 통해 시작할 MVP 버전을 확인합니다.
2.  **규칙 내재화 (Internalize Rules):** 이 문서(`DevHistoryRule.md`)의 모든 규칙을 읽고 완전히 이해합니다.
3.  **상태 평가 (파일 분석) (Assess State (File Analysis)):** 작업 디렉토리 (`/home/woopinbells/Desktop/tmp/clear-claude-prompt/use-portfolio/cpp-multiplayer-game-server`)에서 대상 MVP 시퀀스(예: `grep -r "MVP-X-"`)에 대한 `grep` 검색을 수행하여 현재 버전과 관련된 모든 파일을 식별합니다.
4.  **상태 평가 (기록 검토) (Assess State (History Review)):** 해당 `DevHistoryXX.md` 파일(예: `DevHistory0X.md`)을 읽어 해당 버전의 개발 컨텍스트와 목표를 이해합니다.
5.  **계획 수립 (Formulate Plan):** 규칙, 파일 상태, 개발 기록을 바탕으로 작업을 계속하기 위한 계획을 수립합니다.
6.  **실행 (Execute):** 수립된 모든 코드 수정 및 보존 원칙을 준수하며 계획을 실행합니다.

**7. 프로덕션 고려사항 및 개선 제안 (Production Considerations & Improvement Notes):**
*   각 MVP 문서의 말미에는, 해당 기능들을 실제 프로덕션 환경에서 운영하기 위해 필요한 추가적인 고려사항을 구체적인 코드 예시와 함께 상세히 기술합니다.
*   코드 개선 제안 사항이 있을 경우, `#### 개선 제안 (Improvement Notes):` 섹션에 별도로 명시합니다.

**8. 최소 변경 및 즉시 검증 원칙 (Principle of Minimal Change & Immediate Verification):**
*   **8.1. `replace` 도구 사용 제한:** 파일 전체 또는 여러 줄에 걸친 광범위한 `replace` 작업은 원칙적으로 금지한다. `replace`는 반드시 **단일 행(single-line) 또는 매우 작은, 명확히 식별되는 코드 블록**을 대상으로만 사용해야 한다.
*   **8.2. `write_file` 기반 수정 절차:** 여러 줄 수정이 불가피할 경우, 다음 절차를 반드시 따른다:
    *   가. `read_file`로 수정할 파일의 **정확한 현재 내용**을 읽는다.
    *   나. 수정할 내용을 반영하여, **전체 파일에 대한 새로운 내용**을 메모리 상에서 생성한다.
    *   다. `write_file`을 사용하여 **파일 전체를 덮어쓴다.**
    *   라. **(가장 중요)** 작업 직후, `diff` 명령어를 사용하여 **작업본과 백업본의 차이를 즉시 확인**하고, 의도치 않은 코드 삭제가 없는지 검증한다. 만약 의도치 않은 변경이 발견되면 즉시 사용자에게 보고하고 복원한다.

**9. MVP 복구 및 재문서화 절차 (MVP Recovery & Redocumentation Procedure):**
기존 `DevHistory` 문서가 부정확하거나, 관련 소스 코드가 누락 또는 불완전한 MVP를 처음부터 재정비할 때 사용하는 절차이다. 이 절차는 코드로부터 문서를 재구성하여 100%의 정확성을 보장하는 것을 목표로 한다.

*   **9.1. 코드 우선 탐색 (Code-First Discovery):** `glob`과 `search_file_content`를 사용하여 해당 MVP의 주제(예: "네트워킹", "ECS")와 관련된 모든 소스 파일을 찾는다. 이것이 해당 MVP의 범위를 정의하는 가장 정확한 기준이 된다.
*   **9.2. 누락 코드 생성 (Generation of Missing Code):** 만약 MVP의 핵심 기능에 필수적인 소스 파일이 누락된 경우(예: MVP 1의 `tcp_server.h`), 프로젝트 아키텍처와 다른 문서를 참고하여 해당 파일을 직접 생성한다.
*   **9.3. 문서 재설계 및 상세화 (Redesign and Detail Documentation):** 탐색 및 생성된 모든 파일을 기반으로, `DevHistoryXX.md` 문서를 완전히 새로 작성한다. 각 기능 그룹에 대한 명확한 개요와 "왜"를 설명하는 상세한 설명을 포함해야 한다.
*   **9.4. 코드-문서 완전 동기화 (Full Code-Doc Sync):** 재설계된 문서를 기준으로, 관련된 모든 소스 코드 파일에 `MVPX-Y` 형식의 새롭고 일관된 시퀀스 번호를 부여한다. 이 과정에서 기존의 모든 낡은 주석은 제거되거나 새로운 주석으로 대체된다.

---

## 버전별 목표 및 채용 시장 관점 (Version Goals & Hiring Market Perspective)

이 프로젝트는 여러 MVP(Minimum Viable Product) 단계를 통해 점진적으로 완성됩니다. 각 단계는 명확한 기술적 목표와 함께, 채용 시장에서 어떤 수준의 역량을 보여주는지에 대한 가이드를 제공합니다.

*   **MVP 0: 인프라 및 기반 구축 (Infrastructure & Foundation)**
    *   **목표:** 현대적인 C++ 프로젝트에 필요한 핵심 인프라, 빌드 시스템, 개발 환경을 구축합니다.
    *   **주요 기능:** CMake 빌드 시스템, Conan 의존성 관리, Docker 컨테이너화, 초기 프로젝트 구조 정의.
    *   **포트폴리오 가치:** 전문적인 C++ 프로젝트를 처음부터 설정하고 유지보수할 수 있는 기본적인 역량을 증명합니다.

*   **MVP 1: 핵심 네트워킹 및 서버 루프 (Core Networking & Server Loop)**
    *   **목표:** Boost.Asio를 사용하여 비동기 TCP 서버의 골격을 구축하고, 기본적인 패킷 처리 및 서버의 메인 루프를 구현합니다.
    *   **주요 기능:** TCP 서버, 비동기 I/O, 패킷 핸들러, 로깅 시스템(spdlog), 기본 모니터링.
    *   **포트폴리오 가치:** 게임 서버의 가장 기본적인 요소인 네트워크 통신을 이해하고 구현할 수 있음을 보여줍니다.

*   **MVP 2: 엔티티-컴포넌트-시스템 (Entity-Component-System)**
    *   **목표:** 유연하고 데이터 지향적인 게임 객체 모델링을 위해 ECS 아키텍처의 기반을 다집니다. 기본 버전과 최적화된 버전을 비교 구현합니다.
    *   **주요 기능:** World, Entity, Component, System 클래스, 기본/최적화된 ECS 구현, Transform/Health 컴포넌트, Movement/Health 재생 시스템.
    *   **포트폴리오 가치:** 현대 게임 엔진의 핵심 아키텍처인 ECS를 이해하고, 성능을 고려한 설계를 할 수 있음을 증명합니다.

*   **MVP 3: 공간 분할 (Spatial Partitioning)**
    *   **목표:** 대규모 월드에서 효율적인 공간 질의(spatial query)를 위해 그리드 및 옥트리 기반의 공간 분할 시스템을 구현합니다.
    *   **주요 기능:** World Grid, Octree, 반경 검색, 가시성 검사, 충돌 감지.
    *   **포트폴리오 가치:** 수많은 객체가 존재하는 가상 세계를 효율적으로 관리하고 최적화하는 능력을 보여주는 핵심 기술입니다.

*   **MVP 4: 전투 시스템 (Combat Systems)**
    *   **목표:** 타겟팅 및 논타겟팅(액션) 전투 시스템의 기반을 구현하여 게임의 핵심 플레이를 만듭니다.
    *   **주요 기능:** 타겟팅 시스템, 스킬 시전, 데미지 계산, 액션 전투 시스템, 투사체, 범위 공격(AoE), 회피.
    *   **포트폴리오 가치:** 게임의 가장 중요한 콘텐츠인 전투를 설계하고 구현하는 능력을 증명합니다.

*   **MVP 5: 길드 및 PvP 시스템 (Guild & PvP Systems)**
    *   **목표:** 플레이어 간의 상호작용과 경쟁을 촉진하는 길드전 및 오픈월드 PvP 시스템을 구축합니다.
    *   **주요 기능:** 인스턴스 기반 길드전, 심리스(seamless) 필드 PvP, 영지 점령.
    *   **포트폴리오 가치:** 다중 사용자 간의 복잡한 상호작용과 경쟁 콘텐츠를 설계하는 능력을 보여줍니다.

*   **MVP 6: 프로덕션 레디 (Production Ready)**
    *   **목표:** 배포 자동화(CI/CD), DB 확장성(파티셔닝, 샤딩), 실시간 모니터링, 분산 락 등 실제 서비스 운영에 필수적인 기술들을 통합합니다.
    *   **의미:** '운영 가능한 서비스'를 구축하는 능력을 증명합니다. Mid-level에서 Senior로 넘어가는 개발자에게 요구되는 인프라 및 대규모 시스템 설계 역량을 보여주는, 매우 완성도 높은 포트폴리오입니다.

*   **MVP 7: 동적 월드 & 콘텐츠 기반 (Dynamic World & Content Foundation)**
    *   **목표:** 서버를 살아있는 동적인 세계로 만듭니다. 플레이어가 상호작용하고 탐험할 수 있는 핵심 콘텐츠 시스템을 구축합니다.
    *   **주요 기능:** 고급 월드 시스템(날씨, 주야), NPC 대화, 동적 퀘스트, 심리스 맵 전환.
    *   **포트폴리오 가치:** 플레이어에게 몰입감 있는 경험을 제공하는, 콘텐츠가 풍부한 게임 월드를 구축하는 능력을 증명합니다.

*   **MVP 8: 플레이어 경험 및 생활형 콘텐츠 (Player Experience & Life Content)**
    *   **목표:** 플레이어가 월드 및 콘텐츠와 상호작용하는 데 필요한 모든 핵심 UI/UX 및 생활형/소셜 시스템을 구축합니다.
    *   **주요 기능:** 핵심 UI(HUD, 인벤토리, 채팅, 맵), 하우징, 제작, 고급 하우징(저장소, 권한, 이웃).
    *   **포트폴리오 가치:** 핵심 게임플레이 루프를 넘어, 플레이어의 편의성과 장기적인 재미를 위한 생활형 콘텐츠와 UI/UX를 설계하고 구현하는 능력을 보여줍니다.

*   **MVP 9: 경쟁 시스템 및 라이브 운영 (Competitive Systems & Live Ops)**
    *   **목표:** 플레이어의 장기적인 참여를 유도하는 경쟁 콘텐츠(End-game)와 이를 운영하기 위한 시스템을 구축합니다.
    *   **주요 기능:** 매치메이킹, 랭킹/리더보드, 아레나/토너먼트, 보상 시스템, A/B 테스팅.
    *   **포트폴리오 가치:** 게임의 장기적인 성공과 수익 모델에 직접적으로 기여하는 시스템을 설계하는 능력을 보여줍니다.

*   **MVP 10: 고급 성능 최적화 (Advanced Performance & Optimization)**
    *   **목표:** 대규모 동시 접속자를 처리하기 위해, 서버의 성능을 극한까지 끌어올리는 저수준 최적화 및 현대 C++ 기술을 적용합니다.
    *   **주요 기능:** 고급 네트워킹(클라이언트 예측), C++20 현대화(코루틴), 저수준 최적화(메모리 풀, SIMD), DB 최적화(읽기 복제).
    *   **포트폴리오 가치:** '동작하는' 코드를 넘어 '매우 빠른' 코드를 작성할 수 있음을 증명합니다. 하드웨어와 언어에 대한 깊은 이해를 보여주며, 이는 Senior 및 Specialist 개발자에게 요구되는 핵심 역량입니다.

*   **MVP 11: 프로덕션 최종 강화 (Production Hardening & Finalization)**
    *   **목표:** 가상의 '정식 출시'를 앞두고, 서버의 보안, 안정성, 신뢰도를 최고 수준으로 끌어올립니다.
    *   **주요 기능:** 보안 강화, 종합 부하 테스트, 최종 안정화.
    *   **포트폴리오 가치:** 실제 라이브 서비스를 책임질 수 있는 성숙하고 전문적인 소프트웨어 엔지니어의 역량을 보여줍니다.