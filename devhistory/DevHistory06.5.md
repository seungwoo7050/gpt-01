## MVP 6.5: Unity Client Integration Demo

### [SEQUENCE: MVP6.5-1] Objective
This document outlines the steps and provides the necessary code to create a minimal Unity client. The goal is not to build a full-featured game, but to create a powerful visual demonstration that proves the server's end-to-end functionality. This client will connect to the server, receive game state updates (like player positions), and render them in a 3D space, making the server's capabilities tangible and impactful for a portfolio.

### [SEQUENCE: MVP6.5-2] Key Components
The client will consist of several key C# scripts:

*   **`Generated/` (Folder):** C# classes generated by the Protocol Buffers compiler (`protoc`) from the server's `.proto` files. This ensures the client and server speak the exact same language.
*   **`NetworkManager.cs`:** A core class responsible for handling the TCP connection to the server, including asynchronous reads and writes.
*   **`PacketProcessor.cs`:** A helper class to handle the server's packet protocol (4-byte size header + Protobuf payload) and deserialize incoming messages.
*   **`GameManager.cs`:** A singleton that manages the overall client-side game state, player object spawning, and communication between different manager scripts.
*   **`PlayerController.cs`:** A component to be attached to each player prefab. It will store player data and update the GameObject's transform based on server packets.
*   **`UIManager.cs`:** A simple script to manage the connection UI (IP address input, connect button).

### [SEQUENCE: MVP6.5-3] Step-by-Step Implementation Guide

#### Step 1: Unity Project Setup
1.  Create a new **3D URP (Universal Render Pipeline)** project in Unity Hub.
2.  Install the **Google.Protobuf** library. Go to `Window -> Package Manager`, click the `+` icon, select "Add package from git URL...", and enter `com.google.protobuf`.

#### Step 2: Generate C# Protocol Code
1.  You will need the `protoc` compiler and the C# plugin. If you don't have them, you can download them from the [Protocol Buffers GitHub repository](https://github.com/protocolbuffers/protobuf/releases).
2.  Create a `protos` folder in your Unity project's `Assets` directory.
3.  Copy the server's `.proto` files (`packet.proto`, `auth.proto`, `common.proto`, `game.proto`) into this new `protos` folder.
4.  Create a `Generated` folder inside `Assets/Scripts`.
5.  Run the following command from your Unity project's root directory:
    ```bash
    # [SEQUENCE: MVP6.5-4] Command to generate C# classes from .proto files
    protoc --csharp_out=Assets/Scripts/Generated -I=Assets/protos Assets/protos/*.proto
    ```

#### Step 3: Create C# Scripts
Create the following C# scripts inside the `Assets/Scripts` folder and copy the code provided in the subsequent sections.

*   `NetworkManager.cs`
*   `PacketProcessor.cs`
*   `GameManager.cs`
*   `PlayerController.cs`
*   `UIManager.cs`

#### Step 4: Unity Editor Scene Setup
1.  **Create Managers:** Create an empty GameObject in your scene and name it `_Managers`.
2.  Attach the `GameManager.cs`, `NetworkManager.cs`, and `UIManager.cs` scripts to the `_Managers` GameObject.
3.  **Create Player Prefab:**
    *   Create a 3D Cube (`GameObject -> 3D Object -> Cube`).
    *   Name it `PlayerPrefab`.
    *   Attach the `PlayerController.cs` script to it.
    *   Drag the `PlayerPrefab` from the Hierarchy into the Project window to create a prefab. Delete the instance from the scene.
4.  **Create UI:**
    *   Create a UI Canvas (`GameObject -> UI -> Canvas`).
    *   Add two UI InputFields (`UI -> Input Field (TMP)`) and one Button (`UI -> Button (TMP)`).
    *   Name them `IP_InputField`, `Port_InputField`, and `Connect_Button`.
    *   In the `UIManager` component on your `_Managers` object, drag the corresponding UI elements into the public fields.
    *   Select the `Connect_Button`, find the `OnClick()` event in the Inspector, click `+`, drag the `_Managers` GameObject into the object field, and select `UIManager.OnConnectButtonPressed` from the dropdown.

#### Step 5: Run
1.  Run your C++ server.
2.  Enter Play mode in Unity. Enter the server IP and port, and click the connect button.

### [SEQUENCE: MVP6.5-5] Server Load Testing
To complement the qualitative visual demo, a quantitative load test will be performed to validate the server's performance and stability under pressure. This is crucial for proving the effectiveness of the high-performance architecture.

*   **[SEQUENCE: MVP6.5-6] Objective:** Simulate thousands of concurrent clients to measure throughput (Packets Per Second), latency (RTT), and server resource utilization (CPU/Memory).
*   **[SEQUENCE: MVP6.5-7] Tooling:** The existing C++ `load_test_client` defined in `CMakeLists.txt` will be enhanced to perform the test scenarios.
*   **[SEQUENCE: MVP6.5-8] Test Scenario:**
    1.  **Connection Storm:** A specified number of clients connect to the server as fast as possible.
    2.  **Login:** All connected clients attempt to log in.
    3.  **Movement Simulation:** Each client periodically sends position update packets to the server.
    4.  **Result Aggregation:** The test will conclude by reporting total packets sent/received, average latency, and any errors encountered.
*   **[SEQUENCE: MVP6.5-9] Code Components:** The implementation will be primarily in the `tests/load_test/` directory.

