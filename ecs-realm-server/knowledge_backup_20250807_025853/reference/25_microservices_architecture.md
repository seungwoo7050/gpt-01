# 13ë‹¨ê³„: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ - í•˜ë‚˜ì˜ ê±°ëŒ€í•œ ì„œë²„ë¥¼ ì—¬ëŸ¬ ì „ë¬¸ê°€ë¡œ ë‚˜ëˆ„ê¸°
*ëª¨ë†€ë¦¬ì‹ ì„œë²„ë¥¼ ì‘ì€ ì „ë¬¸ ì„œë¹„ìŠ¤ë“¤ë¡œ ë‚˜ëˆ„ì–´ í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„± ê·¹ëŒ€í™”í•˜ê¸°*

> **ğŸ¯ ëª©í‘œ**: 1000ë§Œ ëª… ë™ì ‘ì´ ê°€ëŠ¥í•œ ë¶„ì‚° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ê²Œì„ ì•„í‚¤í…ì²˜ êµ¬ì¶•í•˜ê¸°

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **ë‚œì´ë„**: ğŸ”´ ê³ ê¸‰ (í•˜ì§€ë§Œ ì°¨ê·¼ì°¨ê·¼ ë”°ë¼í•˜ë©´ ê°€ëŠ¥í•¨!)
- **ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 8-10ì‹œê°„ (ì´ë¡  + ì‹¤ìŠµ)
- **í•„ìš” ì„ ìˆ˜ ì§€ì‹**: 
  - âœ… [1-12ë‹¨ê³„](./01_advanced_cpp_features.md) ëª¨ë“  ë‚´ìš© ì™„ë£Œ
  - âœ… "RESTful API"ê°€ ë­”ì§€ ëŒ€ëµ ì•Œê³  ìˆìŒ
  - âœ… "ë¶„ì‚° ì‹œìŠ¤í…œ"ì„ ë“¤ì–´ë³¸ ì  ìˆìŒ
  - âœ… Docker ê¸°ë³¸ ê°œë… ì´í•´
- **ì‹¤ìŠµ í™˜ê²½**: C++17, Boost.Beast, Consul, Docker, Kubernetes
- **ìµœì¢… ê²°ê³¼ë¬¼**: ë…ë¦½ì ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•œ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ê²Œì„ í”Œë«í¼!

---

## ğŸ¤” ì™œ ê±°ëŒ€í•œ ì„œë²„ í•˜ë‚˜ë³´ë‹¤ ì‘ì€ ì„œë²„ ì—¬ëŸ¬ ê°œê°€ ì¢‹ì„ê¹Œ?

### **ëª¨ë†€ë¦¬ì‹ ì„œë²„ì—ì„œ ì¼ì–´ë‚˜ëŠ” ë¬¸ì œë“¤**

```
ğŸ˜° í•˜ë‚˜ì˜ ê±°ëŒ€í•œ ì„œë²„ì—ì„œ ë²Œì–´ì§€ëŠ” ì¬ì•™ë“¤

ğŸ¢ íšŒì‚¬ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°:
â”œâ”€â”€ "ëª¨ë“  ì§ì›ì´ í•œ ê±´ë¬¼ì—ì„œ ëª¨ë“  ì¼ì„ ì²˜ë¦¬" ğŸ¢
â”œâ”€â”€ CEOë¶€í„° ì²­ì†Œë¶€ê¹Œì§€ í•œ ì‚¬ë¬´ì‹¤ì—... ğŸ˜µ
â”œâ”€â”€ íšŒê³„íŒ€ ë¬¸ì œë¡œ ì „ì²´ íšŒì‚¬ ë§ˆë¹„! ğŸ’€
â”œâ”€â”€ ë§ˆì¼€íŒ…íŒ€ í™•ì¥í•˜ë ¤ë©´ ì „ì²´ ê±´ë¬¼ ì´ì‚¬? ğŸšš
â””â”€â”€ í•œ ëª… ì‹¤ìˆ˜í•˜ë©´ ëª¨ë“  ë¶€ì„œ ì˜í–¥... ğŸ˜±

ğŸ® ê²Œì„ ì„œë²„ë¡œ ë²ˆì—­í•˜ë©´:
â”œâ”€â”€ ë¡œê·¸ì¸, ê²Œì„ë¡œì§, ê¸¸ë“œ, ì±„íŒ… ëª¨ë‘ í•œ í”„ë¡œê·¸ë¨
â”œâ”€â”€ ì±„íŒ… ì„œë²„ ë¬¸ì œë¡œ ì „ì²´ ê²Œì„ ë‹¤ìš´
â”œâ”€â”€ ê¸¸ë“œì „ ë§ì•„ì§€ë©´ ì „ì²´ ì„œë²„ ì—…ê·¸ë ˆì´ë“œ
â”œâ”€â”€ í•œ ê¸°ëŠ¥ ë²„ê·¸ë¡œ ëª¨ë“  í”Œë ˆì´ì–´ ì˜í–¥
â””â”€â”€ ìƒˆ ê¸°ëŠ¥ ì¶”ê°€í•˜ë©´ ì „ì²´ ì„œë²„ ì¬ì‹œì‘
```

### **ì‹¤ì œ ëª¨ë†€ë¦¬ì‹ ì„œë²„ì˜ ë”ì°í•œ ì‚¬ë¡€**

```cpp
// ğŸ˜° ëª¨ë“  ê¸°ëŠ¥ì´ í•œ ë©ì–´ë¦¬ì¸ ê´´ë¬¼ ì„œë²„

class MonolithicGameServer {
public:
    // ğŸ’€ ë¬¸ì œ: ëª¨ë“  ê¸°ëŠ¥ì´ í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ì—...
    AuthenticationManager auth_manager_;
    PlayerManager player_manager_;
    GuildManager guild_manager_;
    WorldManager world_manager_;
    ChatManager chat_manager_;
    ShopManager shop_manager_;
    DatabaseManager database_manager_;
    
    void Start() {
        // ğŸ˜± í•œ ê¸°ëŠ¥ì´ë¼ë„ ì´ˆê¸°í™” ì‹¤íŒ¨í•˜ë©´ ì „ì²´ ì„œë²„ ì£½ìŒ
        auth_manager_.Initialize();
        player_manager_.Initialize();
        guild_manager_.Initialize();  // ê¸¸ë“œ DB ë¬¸ì œë¡œ ì‹¤íŒ¨!
        // ì „ì²´ ì„œë²„ ì‹œì‘ ë¶ˆê°€ëŠ¥... ğŸ˜­
    }
    
    void HandleRequest(const Request& request) {
        // ğŸ˜° ì±„íŒ… ìš”ì²­ í­ì¦ìœ¼ë¡œ ì „ì²´ ì„œë²„ ê³¼ë¶€í•˜
        if (request.type == "chat") {
            chat_manager_.HandleChat(request);  // CPU 100% ì‚¬ìš©
        }
        // ë‹¤ë¥¸ ëª¨ë“  ê¸°ëŠ¥ë„ ëŠë ¤ì§... ğŸ˜µ
    }
};

// ğŸ˜° ì‹¤ì œ ë²Œì–´ì§€ëŠ” ì¬ì•™ë“¤:
void DemoMonolithProblems() {
    MonolithicGameServer server;
    
    // ğŸ˜± ë¬¸ì œ 1: í™•ì¥ì„± ì¬ì•™
    std::cout << "ì±„íŒ… ì‚¬ìš©ì ê¸‰ì¦!" << std::endl;
    std::cout << "â†’ ì±„íŒ…ë§Œ í™•ì¥í•˜ë ¤ë©´? ì „ì²´ ì„œë²„ 10ë°° ëŠ˜ë ¤ì•¼ í•¨" << std::endl;
    std::cout << "â†’ ë¹„ìš©: ì›” $10,000 â†’ $100,000 ğŸ˜­" << std::endl;
    
    // ğŸ˜± ë¬¸ì œ 2: ë°°í¬ ì§€ì˜¥
    std::cout << "\nìƒˆ ì±„íŒ… ê¸°ëŠ¥ ì¶”ê°€" << std::endl;
    std::cout << "â†’ ì „ì²´ ì„œë²„ ì¬ì‹œì‘ í•„ìš”" << std::endl;
    std::cout << "â†’ ëª¨ë“  í”Œë ˆì´ì–´ ê°•ì œ ë¡œê·¸ì•„ì›ƒ ğŸ’€" << std::endl;
    
    // ğŸ˜± ë¬¸ì œ 3: ì¥ì•  ì „íŒŒ
    std::cout << "\nê¸¸ë“œ ê¸°ëŠ¥ì— ë²„ê·¸ ë°œìƒ" << std::endl;
    std::cout << "â†’ ì „ì²´ ì„œë²„ í¬ë˜ì‹œ" << std::endl;
    std::cout << "â†’ ë¡œê·¸ì¸, ê²Œì„, ì±„íŒ… ëª¨ë‘ ë§ˆë¹„ ğŸ˜µ" << std::endl;
}
```

### **ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ì˜ ë†€ë¼ìš´ í•´ê²°ì±… âœ¨**

```cpp
// âœ¨ ê°ì ì „ë¬¸ë¶„ì•¼ê°€ ìˆëŠ” ì‘ì€ ì„œë¹„ìŠ¤ë“¤

class MicroservicesArchitecture {
public:
    // ğŸ¯ ê° ì„œë¹„ìŠ¤ê°€ ë…ë¦½ì ìœ¼ë¡œ ë™ì‘!
    struct Services {
        AuthService auth_service;      // í¬íŠ¸ 8001: ì¸ì¦ ì „ë¬¸
        PlayerService player_service;  // í¬íŠ¸ 8002: í”Œë ˆì´ì–´ ê´€ë¦¬ ì „ë¬¸
        GuildService guild_service;    // í¬íŠ¸ 8003: ê¸¸ë“œ ì „ë¬¸
        ChatService chat_service;      // í¬íŠ¸ 8004: ì±„íŒ… ì „ë¬¸
        WorldService world_service;    // í¬íŠ¸ 8005: ê²Œì„ì›”ë“œ ì „ë¬¸
    };
    
    void StartServices() {
        // ğŸ˜ ê° ì„œë¹„ìŠ¤ê°€ ë…ë¦½ì ìœ¼ë¡œ ì‹œì‘!
        std::vector<std::thread> service_threads;
        
        service_threads.emplace_back([]() {
            AuthService auth;
            auth.Start(8001);  // ì¸ì¦ ì„œë¹„ìŠ¤ ì‹œì‘
        });
        
        service_threads.emplace_back([]() {
            ChatService chat;
            chat.Start(8004);  // ì±„íŒ… ì„œë¹„ìŠ¤ ì‹œì‘
        });
        
        // âœ¨ ê¸¸ë“œ ì„œë¹„ìŠ¤ ë¬¸ì œ ìˆì–´ë„ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ëŠ” ì •ìƒ ë™ì‘!
        try {
            GuildService guild;
            guild.Start(8003);
        } catch (const std::exception& e) {
            std::cout << "ê¸¸ë“œ ì„œë¹„ìŠ¤ë§Œ ë¬¸ì œ, ë‹¤ë¥¸ ì„œë¹„ìŠ¤ëŠ” ì •ìƒ! âœ¨" << std::endl;
        }
    }
    
    void HandleGrowth() {
        // ğŸš€ ì±„íŒ… ì‚¬ìš©ì ê¸‰ì¦? ì±„íŒ… ì„œë¹„ìŠ¤ë§Œ í™•ì¥!
        for (int i = 0; i < 10; ++i) {
            StartChatService(8004 + i);  // ì±„íŒ… ì„œë¹„ìŠ¤ 10ê°œ ì‹¤í–‰
        }
        
        // ğŸ˜ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ëŠ” ê·¸ëŒ€ë¡œ! ë¹„ìš© 10ë¶„ì˜ 1ë¡œ í•´ê²°!
        std::cout << "ì±„íŒ… ì„œë¹„ìŠ¤ë§Œ 10ë°° í™•ì¥ ì™„ë£Œ!" << std::endl;
        std::cout << "ë¹„ìš© ì ˆì•½: $90,000/ì›” ğŸ’°" << std::endl;
    }
};

// ğŸ® ë†€ë¼ìš´ ê°œì„  ê²°ê³¼
void DemoMicroservices() {
    std::cout << "ğŸ¢ ëª¨ë†€ë¦¬ìŠ¤ vs ğŸ—ï¸ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤" << std::endl;
    std::cout << "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" << std::endl;
    
    std::cout << "í™•ì¥ì„±:" << std::endl;
    std::cout << "ëª¨ë†€ë¦¬ìŠ¤: ì „ì²´ ì„œë²„ 10ë°° í™•ì¥ ($100,000/ì›”) ğŸ˜°" << std::endl;
    std::cout << "ë§ˆì´í¬ë¡œ: í•„ìš”í•œ ì„œë¹„ìŠ¤ë§Œ í™•ì¥ ($10,000/ì›”) ğŸš€" << std::endl;
    
    std::cout << "\në°°í¬:" << std::endl;
    std::cout << "ëª¨ë†€ë¦¬ìŠ¤: ì „ì²´ ì„œë²„ ì¬ì‹œì‘ (ëª¨ë“  í”Œë ˆì´ì–´ ë¡œê·¸ì•„ì›ƒ) ğŸ’€" << std::endl;
    std::cout << "ë§ˆì´í¬ë¡œ: í•´ë‹¹ ì„œë¹„ìŠ¤ë§Œ ì¬ì‹œì‘ (ë¬´ì¤‘ë‹¨ ë°°í¬) âœ¨" << std::endl;
    
    std::cout << "\nì¥ì•  ì²˜ë¦¬:" << std::endl;
    std::cout << "ëª¨ë†€ë¦¬ìŠ¤: í•œ ê¸°ëŠ¥ ë¬¸ì œë¡œ ì „ì²´ ì„œë¹„ìŠ¤ ë‹¤ìš´ ğŸ˜­" << std::endl;
    std::cout << "ë§ˆì´í¬ë¡œ: í•´ë‹¹ ì„œë¹„ìŠ¤ë§Œ ë¬¸ì œ, ë‹¤ë¥¸ ê¸°ëŠ¥ ì •ìƒ ğŸ›¡ï¸" << std::endl;
}
```

**ğŸ’¡ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ì˜ í•µì‹¬ ê°œë…:**
- **ì„œë¹„ìŠ¤ ë¶„í•´**: í° ì„œë²„ë¥¼ ì‘ì€ ì „ë¬¸ ì„œë¹„ìŠ¤ë“¤ë¡œ ë‚˜ëˆ„ê¸°
- **ë…ë¦½ ë°°í¬**: ê° ì„œë¹„ìŠ¤ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ê°€ëŠ¥
- **ê¸°ìˆ  ë‹¤ì–‘ì„±**: ì„œë¹„ìŠ¤ë§ˆë‹¤ ì í•©í•œ ê¸°ìˆ  ì„ íƒ ê°€ëŠ¥
- **ì¥ì•  ê²©ë¦¬**: í•œ ì„œë¹„ìŠ¤ ë¬¸ì œê°€ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ì— ì˜í–¥ ì—†ìŒ
- **íŒ€ ììœ¨ì„±**: ê° íŒ€ì´ ìì‹ ì˜ ì„œë¹„ìŠ¤ë¥¼ ì™„ì „íˆ ì†Œìœ 

## ğŸ“š ìš°ë¦¬ MMORPG ì„œë²„ì˜ ì§„í™” ê³¼ì •

```
ğŸ—ï¸ ë‹¨ê³„ë³„ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì „í™˜ ë¡œë“œë§µ

í˜„ì¬ (ëª¨ë†€ë¦¬ìŠ¤): í•˜ë‚˜ì˜ ê±°ëŒ€í•œ ì„œë²„
â””â”€â”€ ëª¨ë“  ê¸°ëŠ¥ì´ í•œ í”„ë¡œê·¸ë¨ ì•ˆì—
    â”œâ”€â”€ ê´€ë¦¬í•˜ê¸° ì‰¬ì›€ (ì²˜ìŒì—ëŠ”...)
    â”œâ”€â”€ ë°°í¬ ë‹¨ìˆœí•¨ (ì „ì²´ë¥¼ í•œ ë²ˆì—)
    â””â”€â”€ ì„œë²„ 3-5ê°œê¹Œì§€ë§Œ í™•ì¥ ê°€ëŠ¥

1ë‹¨ê³„ (í•µì‹¬ ì„œë¹„ìŠ¤ ë¶„ë¦¬): ìœ„í—˜ ì—†ëŠ” ê²ƒë¶€í„°
â”œâ”€â”€ ì¸ì¦ ì„œë¹„ìŠ¤ ë¶„ë¦¬ (ê°€ì¥ ì•ˆì „í•¨)
â”œâ”€â”€ í”Œë ˆì´ì–´ ì„œë¹„ìŠ¤ ë¶„ë¦¬
â”œâ”€â”€ ê¸¸ë“œ ì„œë¹„ìŠ¤ ë¶„ë¦¬
â””â”€â”€ ì„œë²„ 10-20ê°œê¹Œì§€ í™•ì¥ ê°€ëŠ¥

2ë‹¨ê³„ (API ê²Œì´íŠ¸ì›¨ì´): ì…êµ¬ í†µí•© ê´€ë¦¬
â”œâ”€â”€ API ê²Œì´íŠ¸ì›¨ì´ ë„ì… (ëª¨ë“  ìš”ì²­ì˜ ê´€ë¬¸)
â”œâ”€â”€ ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬ (ì„œë¹„ìŠ¤ë“¤ì´ ì„œë¡œ ì°¾ê¸°)
â”œâ”€â”€ ë¡œë“œ ë°¸ëŸ°ì‹± (ë¶€í•˜ ë¶„ì‚°)
â””â”€â”€ ì„œë²„ 50-100ê°œê¹Œì§€ í™•ì¥ ê°€ëŠ¥

3ë‹¨ê³„ (ê³ ê¸‰ íŒ¨í„´): ì—”í„°í”„ë¼ì´ì¦ˆê¸‰
â”œâ”€â”€ ì„œí‚· ë¸Œë ˆì´ì»¤ (ì¥ì•  ê²©ë¦¬)
â”œâ”€â”€ ë¶„ì‚° ì¶”ì  (ë¬¸ì œ ì›ì¸ ì°¾ê¸°)
â”œâ”€â”€ ì´ë²¤íŠ¸ ì†Œì‹± (ëª¨ë“  ë³€ê²½ ê¸°ë¡)
â””â”€â”€ ì„œë²„ 1000ê°œ+ í™•ì¥ ê°€ëŠ¥ (1000ë§Œ ë™ì ‘!)
```

---

## ğŸ¯ Service Decomposition Strategy

### Domain-Driven Service Boundaries

**`src/microservices/service_boundaries.h` - Design:**
```cpp
// [SEQUENCE: 1] Service boundary definitions based on game domains
namespace GameServices {
    
    // [SEQUENCE: 2] Authentication & Authorization Service
    struct AuthService {
        static constexpr const char* SERVICE_NAME = "auth-service";
        static constexpr int DEFAULT_PORT = 8001;
        
        struct Responsibilities {
            // User authentication and JWT token management
            // Session validation and refresh
            // Password policies and security
            // OAuth integration (Steam, Discord, etc.)
        };
        
        struct APIs {
            // POST /auth/login
            // POST /auth/refresh
            // POST /auth/logout
            // GET /auth/validate
        };
    };
    
    // [SEQUENCE: 3] Player Management Service
    struct PlayerService {
        static constexpr const char* SERVICE_NAME = "player-service";
        static constexpr int DEFAULT_PORT = 8002;
        
        struct Responsibilities {
            // Player profile and character management
            // Inventory and equipment
            // Player statistics and progression
            // Friends and social connections
        };
        
        struct DataOwnership {
            // players table
            // character_stats table  
            // player_inventory table
            // player_friends table
        };
    };
    
    // [SEQUENCE: 4] Guild & Social Service
    struct GuildService {
        static constexpr const char* SERVICE_NAME = "guild-service";
        static constexpr int DEFAULT_PORT = 8003;
        
        struct Responsibilities {
            // Guild creation and management
            // Guild wars and large-scale PvP
            // Chat and messaging systems
            // Social features (parties, alliances)
        };
        
        struct EventsProduced {
            // guild.created
            // guild.war.started
            // guild.member.joined
            // chat.message.sent
        };
    };
    
    // [SEQUENCE: 5] World & Game Logic Service
    struct WorldService {
        static constexpr const char* SERVICE_NAME = "world-service";
        static constexpr int DEFAULT_PORT = 8004;
        
        struct Responsibilities {
            // Game world state management
            // Real-time combat and movement
            // NPC and monster AI
            // World events and spawning
        };
        
        struct PerformanceRequirements {
            static constexpr int MAX_LATENCY_MS = 50;
            static constexpr int TARGET_TPS = 60;  // Ticks per second
            static constexpr int MAX_CONCURRENT_PLAYERS = 2000;
        };
    };
    
    // [SEQUENCE: 6] Analytics & Metrics Service
    struct AnalyticsService {
        static constexpr const char* SERVICE_NAME = "analytics-service";
        static constexpr int DEFAULT_PORT = 8005;
        
        struct Responsibilities {
            // Player behavior analytics
            // Game balance metrics
            // Real-time monitoring dashboards
            // A/B testing framework
        };
    };
}
```

### Service Implementation Template

**Base Service Framework:**
```cpp
// [SEQUENCE: 7] Common microservice base class
#include <boost/asio.hpp>
#include <nlohmann/json.hpp>
#include <spdlog/spdlog.h>

template<typename ServiceConfig>
class MicroserviceBase {
protected:
    boost::asio::io_context io_context_;
    std::unique_ptr<boost::asio::ip::tcp::acceptor> acceptor_;
    
    // Service discovery and health
    std::unique_ptr<ServiceDiscoveryClient> discovery_client_;
    std::unique_ptr<HealthChecker> health_checker_;
    
    // Configuration and metrics
    ServiceConfig config_;
    std::shared_ptr<PrometheusMetrics> metrics_;
    
public:
    MicroserviceBase(const ServiceConfig& config) : config_(config) {
        // [SEQUENCE: 8] Initialize common components
        metrics_ = std::make_shared<PrometheusMetrics>(config_.service_name);
        discovery_client_ = std::make_unique<ServiceDiscoveryClient>(config_.consul_address);
        health_checker_ = std::make_unique<HealthChecker>();
        
        // [SEQUENCE: 9] Set up HTTP server
        acceptor_ = std::make_unique<boost::asio::ip::tcp::acceptor>(
            io_context_, 
            boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), config_.port)
        );
    }
    
    // [SEQUENCE: 10] Service lifecycle management
    virtual void Start() {
        // Register with service discovery
        ServiceRegistration registration{
            .service_name = config_.service_name,
            .service_id = GenerateServiceId(),
            .address = GetLocalIP(),
            .port = config_.port,
            .health_check_url = fmt::format("http://{}:{}/health", GetLocalIP(), config_.port),
            .tags = {"game-server", "microservice"}
        };
        
        discovery_client_->RegisterService(registration);
        
        // Start health check endpoint
        StartHealthCheckEndpoint();
        
        // Start accepting HTTP requests
        StartAcceptLoop();
        
        spdlog::info("{} started on port {}", config_.service_name, config_.port);
    }
    
    virtual void Stop() {
        // Deregister from service discovery
        discovery_client_->DeregisterService();
        
        // Graceful shutdown
        acceptor_->close();
        io_context_.stop();
        
        spdlog::info("{} stopped", config_.service_name);
    }
    
    // [SEQUENCE: 11] HTTP request routing (must be implemented by derived classes)
    virtual nlohmann::json HandleRequest(const std::string& method, 
                                       const std::string& path,
                                       const nlohmann::json& body) = 0;
    
private:
    // [SEQUENCE: 12] HTTP request handling
    void StartAcceptLoop() {
        auto session = std::make_shared<HttpSession>(io_context_, *this);
        acceptor_->async_accept(session->GetSocket(),
            [this, session](boost::system::error_code ec) {
                if (!ec) {
                    session->Start();
                }
                StartAcceptLoop();  // Continue accepting
            });
    }
    
    void StartHealthCheckEndpoint() {
        // [SEQUENCE: 13] Health check implementation
        health_checker_->RegisterCheck("database", [this]() {
            return CheckDatabaseConnection();
        });
        
        health_checker_->RegisterCheck("memory", [this]() {
            return GetMemoryUsage() < config_.max_memory_mb;
        });
        
        health_checker_->RegisterCheck("cpu", [this]() {
            return GetCPUUsage() < config_.max_cpu_percent;
        });
    }
};
```

---

## ğŸšª API Gateway Implementation

### Centralized Request Routing

**`src/microservices/api_gateway/gateway_server.h` - Implementation:**
```cpp
// [SEQUENCE: 14] API Gateway for microservices routing
#include <boost/beast.hpp>
#include <boost/asio.hpp>
#include <unordered_map>

class APIGateway {
private:
    boost::asio::io_context io_context_;
    boost::beast::http::response<boost::beast::http::string_body> response_;
    
    // Service discovery and load balancing
    std::unique_ptr<ServiceDiscoveryClient> discovery_client_;
    std::unique_ptr<LoadBalancer> load_balancer_;
    
    // Rate limiting and authentication
    std::unique_ptr<RateLimiter> rate_limiter_;
    std::unique_ptr<JWTValidator> jwt_validator_;
    
    // Route configuration
    struct Route {
        std::string path_pattern;
        std::string target_service;
        std::vector<std::string> methods;
        bool requires_auth;
        int rate_limit_per_minute;
    };
    
    std::vector<Route> routes_;
    
public:
    APIGateway(const GatewayConfig& config) {
        // [SEQUENCE: 15] Initialize gateway components
        discovery_client_ = std::make_unique<ServiceDiscoveryClient>(config.consul_address);
        load_balancer_ = std::make_unique<RoundRobinLoadBalancer>();
        rate_limiter_ = std::make_unique<TokenBucketRateLimiter>();
        jwt_validator_ = std::make_unique<JWTValidator>(config.jwt_secret);
        
        // [SEQUENCE: 16] Configure routing rules
        ConfigureRoutes();
    }
    
    // [SEQUENCE: 17] Main request handling pipeline
    boost::beast::http::response<boost::beast::http::string_body> 
    HandleRequest(boost::beast::http::request<boost::beast::http::string_body> request) {
        
        std::string client_ip = ExtractClientIP(request);
        std::string path = std::string(request.target());
        std::string method = std::string(request.method_string());
        
        try {
            // [SEQUENCE: 18] Authentication middleware
            if (!AuthenticateRequest(request)) {
                return CreateErrorResponse(401, "Unauthorized");
            }
            
            // [SEQUENCE: 19] Rate limiting middleware
            if (!rate_limiter_->AllowRequest(client_ip)) {
                return CreateErrorResponse(429, "Too Many Requests");
            }
            
            // [SEQUENCE: 20] Route matching and service discovery
            auto route = FindMatchingRoute(path, method);
            if (!route) {
                return CreateErrorResponse(404, "Route Not Found");
            }
            
            auto service_instances = discovery_client_->GetHealthyInstances(route->target_service);
            if (service_instances.empty()) {
                return CreateErrorResponse(503, "Service Unavailable");
            }
            
            // [SEQUENCE: 21] Load balancing
            auto target_instance = load_balancer_->SelectInstance(service_instances);
            
            // [SEQUENCE: 22] Forward request to microservice
            auto response = ForwardRequest(request, target_instance);
            
            // [SEQUENCE: 23] Response middleware (logging, metrics)
            LogRequest(client_ip, path, method, response.result_int());
            metrics_->IncrementCounter("requests_total", {
                {"service", route->target_service},
                {"status", std::to_string(response.result_int())}
            });
            
            return response;
            
        } catch (const std::exception& e) {
            spdlog::error("Gateway error: {}", e.what());
            return CreateErrorResponse(500, "Internal Server Error");
        }
    }
    
private:
    // [SEQUENCE: 24] Route configuration for game services
    void ConfigureRoutes() {
        routes_ = {
            // Authentication routes
            {"/api/auth/.*", "auth-service", {"POST", "GET"}, false, 100},
            
            // Player management routes
            {"/api/players/.*", "player-service", {"GET", "POST", "PUT"}, true, 1000},
            
            // Guild operations
            {"/api/guilds/.*", "guild-service", {"GET", "POST", "PUT", "DELETE"}, true, 500},
            
            // World and game state
            {"/api/world/.*", "world-service", {"GET", "POST"}, true, 2000},
            
            // Real-time game actions (WebSocket upgrade)
            {"/ws/game", "world-service", {"GET"}, true, 10000},
            
            // Analytics and metrics
            {"/api/analytics/.*", "analytics-service", {"GET"}, true, 100}
        };
    }
    
    // [SEQUENCE: 25] JWT authentication middleware
    bool AuthenticateRequest(const boost::beast::http::request<boost::beast::http::string_body>& request) {
        std::string path = std::string(request.target());
        
        // [SEQUENCE: 26] Skip auth for public endpoints
        if (path.starts_with("/api/auth/login") || 
            path.starts_with("/api/auth/register") ||
            path == "/health") {
            return true;
        }
        
        // [SEQUENCE: 27] Extract and validate JWT token
        auto auth_header = request.find("Authorization");
        if (auth_header == request.end()) {
            return false;
        }
        
        std::string auth_value = std::string(auth_header->value());
        if (!auth_value.starts_with("Bearer ")) {
            return false;
        }
        
        std::string token = auth_value.substr(7);  // Remove "Bearer "
        return jwt_validator_->ValidateToken(token);
    }
    
    // [SEQUENCE: 28] Service-to-service communication
    boost::beast::http::response<boost::beast::http::string_body> 
    ForwardRequest(const boost::beast::http::request<boost::beast::http::string_body>& request,
                  const ServiceInstance& target) {
        
        try {
            // [SEQUENCE: 29] Create HTTP client connection
            boost::asio::ip::tcp::resolver resolver(io_context_);
            auto const results = resolver.resolve(target.address, std::to_string(target.port));
            
            boost::beast::tcp_stream stream(io_context_);
            stream.connect(results);
            
            // [SEQUENCE: 30] Forward the request
            boost::beast::http::write(stream, request);
            
            // [SEQUENCE: 31] Read the response
            boost::beast::flat_buffer buffer;
            boost::beast::http::response<boost::beast::http::string_body> response;
            boost::beast::http::read(stream, buffer, response);
            
            // [SEQUENCE: 32] Add gateway headers
            response.set("X-Gateway-Service", target.service_name);
            response.set("X-Gateway-Instance", target.instance_id);
            
            stream.socket().shutdown(boost::asio::ip::tcp::socket::shutdown_both);
            
            return response;
            
        } catch (const std::exception& e) {
            spdlog::error("Request forwarding error: {}", e.what());
            return CreateErrorResponse(502, "Bad Gateway");
        }
    }
};
```

### Circuit Breaker Pattern

**Resilient Service Communication:**
```cpp
// [SEQUENCE: 33] Circuit breaker for service resilience
class CircuitBreaker {
private:
    enum class State {
        CLOSED,    // Normal operation
        OPEN,      // Failing fast
        HALF_OPEN  // Testing recovery
    };
    
    State state_ = State::CLOSED;
    int failure_count_ = 0;
    int success_count_ = 0;
    std::chrono::steady_clock::time_point last_failure_time_;
    
    // Configuration
    int failure_threshold_ = 5;
    int success_threshold_ = 3;
    std::chrono::seconds timeout_ = std::chrono::seconds(60);
    
public:
    // [SEQUENCE: 34] Execute request with circuit breaker protection
    template<typename Func>
    auto Execute(Func&& func) -> decltype(func()) {
        switch (state_) {
            case State::OPEN:
                // [SEQUENCE: 35] Check if we should attempt recovery
                if (std::chrono::steady_clock::now() - last_failure_time_ > timeout_) {
                    state_ = State::HALF_OPEN;
                    success_count_ = 0;
                    spdlog::info("Circuit breaker transitioning to HALF_OPEN");
                } else {
                    throw CircuitBreakerOpenException("Circuit breaker is OPEN");
                }
                break;
                
            case State::HALF_OPEN:
                // [SEQUENCE: 36] Limited requests in half-open state
                break;
                
            case State::CLOSED:
                // [SEQUENCE: 37] Normal operation
                break;
        }
        
        try {
            auto result = func();
            OnSuccess();
            return result;
            
        } catch (const std::exception& e) {
            OnFailure();
            throw;
        }
    }
    
private:
    void OnSuccess() {
        failure_count_ = 0;
        
        if (state_ == State::HALF_OPEN) {
            success_count_++;
            if (success_count_ >= success_threshold_) {
                state_ = State::CLOSED;
                spdlog::info("Circuit breaker transitioned to CLOSED");
            }
        }
    }
    
    void OnFailure() {
        failure_count_++;
        last_failure_time_ = std::chrono::steady_clock::now();
        
        if (state_ == State::HALF_OPEN) {
            state_ = State::OPEN;
            spdlog::warn("Circuit breaker transitioned to OPEN from HALF_OPEN");
        } else if (failure_count_ >= failure_threshold_) {
            state_ = State::OPEN;
            spdlog::warn("Circuit breaker transitioned to OPEN due to failures");
        }
    }
};
```

---

## ğŸ” Service Discovery & Configuration

### Consul Integration

**`src/microservices/service_discovery/consul_client.h` - Implementation:**
```cpp
// [SEQUENCE: 38] Consul service discovery client
#include <curl/curl.h>
#include <nlohmann/json.hpp>

class ConsulServiceDiscovery {
private:
    std::string consul_address_;
    std::unique_ptr<CURL, decltype(&curl_easy_cleanup)> curl_;
    
    // Service health monitoring
    std::thread health_monitor_thread_;
    std::atomic<bool> should_stop_{false};
    
public:
    ConsulServiceDiscovery(const std::string& consul_address) 
        : consul_address_(consul_address),
          curl_(curl_easy_init(), &curl_easy_cleanup) {
        
        if (!curl_) {
            throw std::runtime_error("Failed to initialize CURL");
        }
        
        // [SEQUENCE: 39] Start health monitoring thread
        health_monitor_thread_ = std::thread(&ConsulServiceDiscovery::HealthMonitorLoop, this);
    }
    
    ~ConsulServiceDiscovery() {
        should_stop_ = true;
        if (health_monitor_thread_.joinable()) {
            health_monitor_thread_.join();
        }
    }
    
    // [SEQUENCE: 40] Register service with Consul
    bool RegisterService(const ServiceRegistration& registration) {
        nlohmann::json service_json = {
            {"ID", registration.service_id},
            {"Name", registration.service_name},
            {"Address", registration.address},
            {"Port", registration.port},
            {"Tags", registration.tags},
            {"Check", {
                {"HTTP", registration.health_check_url},
                {"Interval", "10s"},
                {"Timeout", "3s"},
                {"DeregisterCriticalServiceAfter", "30s"}
            }}
        };
        
        std::string url = fmt::format("{}/v1/agent/service/register", consul_address_);
        std::string response;
        
        // [SEQUENCE: 41] HTTP PUT request to Consul
        curl_easy_setopt(curl_.get(), CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl_.get(), CURLOPT_CUSTOMREQUEST, "PUT");
        curl_easy_setopt(curl_.get(), CURLOPT_POSTFIELDS, service_json.dump().c_str());
        curl_easy_setopt(curl_.get(), CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl_.get(), CURLOPT_WRITEDATA, &response);
        
        CURLcode res = curl_easy_perform(curl_.get());
        
        if (res == CURLE_OK) {
            long response_code;
            curl_easy_getinfo(curl_.get(), CURLINFO_RESPONSE_CODE, &response_code);
            
            if (response_code == 200) {
                spdlog::info("Service {} registered with Consul", registration.service_name);
                return true;
            }
        }
        
        spdlog::error("Failed to register service with Consul: {}", curl_easy_strerror(res));
        return false;
    }
    
    // [SEQUENCE: 42] Discover healthy service instances
    std::vector<ServiceInstance> GetHealthyInstances(const std::string& service_name) {
        std::string url = fmt::format("{}/v1/health/service/{}?passing=true", 
                                     consul_address_, service_name);
        std::string response;
        
        curl_easy_setopt(curl_.get(), CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl_.get(), CURLOPT_HTTPGET, 1L);
        curl_easy_setopt(curl_.get(), CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl_.get(), CURLOPT_WRITEDATA, &response);
        
        CURLcode res = curl_easy_perform(curl_.get());
        std::vector<ServiceInstance> instances;
        
        if (res == CURLE_OK) {
            try {
                // [SEQUENCE: 43] Parse Consul response
                nlohmann::json consul_response = nlohmann::json::parse(response);
                
                for (const auto& entry : consul_response) {
                    if (entry.contains("Service")) {
                        const auto& service = entry["Service"];
                        
                        ServiceInstance instance;
                        instance.service_name = service["Service"];
                        instance.instance_id = service["ID"];
                        instance.address = service["Address"];
                        instance.port = service["Port"];
                        instance.tags = service["Tags"];
                        
                        instances.push_back(instance);
                    }
                }
                
            } catch (const nlohmann::json::exception& e) {
                spdlog::error("Failed to parse Consul response: {}", e.what());
            }
        }
        
        return instances;
    }
    
    // [SEQUENCE: 44] Configuration management
    std::optional<std::string> GetConfigValue(const std::string& key) {
        std::string url = fmt::format("{}/v1/kv/{}", consul_address_, key);
        std::string response;
        
        curl_easy_setopt(curl_.get(), CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl_.get(), CURLOPT_HTTPGET, 1L);
        curl_easy_setopt(curl_.get(), CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl_.get(), CURLOPT_WRITEDATA, &response);
        
        CURLcode res = curl_easy_perform(curl_.get());
        
        if (res == CURLE_OK) {
            try {
                nlohmann::json kv_response = nlohmann::json::parse(response);
                if (!kv_response.empty()) {
                    std::string encoded_value = kv_response[0]["Value"];
                    // Base64 decode the value (Consul stores values as base64)
                    return Base64Decode(encoded_value);
                }
            } catch (const nlohmann::json::exception& e) {
                spdlog::error("Failed to parse KV response: {}", e.what());
            }
        }
        
        return std::nullopt;
    }
    
private:
    // [SEQUENCE: 45] Health monitoring background thread
    void HealthMonitorLoop() {
        while (!should_stop_) {
            try {
                // Monitor service health and update local cache
                RefreshServiceCache();
                
                std::this_thread::sleep_for(std::chrono::seconds(30));
                
            } catch (const std::exception& e) {
                spdlog::error("Health monitor error: {}", e.what());
            }
        }
    }
    
    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* response) {
        size_t total_size = size * nmemb;
        response->append(static_cast<char*>(contents), total_size);
        return total_size;
    }
};
```

---

## ğŸ“Š Inter-Service Communication Patterns

### Event-Driven Communication

**Service Event Bus Implementation:**
```cpp
// [SEQUENCE: 46] Event-driven inter-service communication
class ServiceEventBus {
private:
    std::shared_ptr<RabbitMQManager> message_queue_;
    std::unordered_map<std::string, std::vector<EventHandler>> event_handlers_;
    
public:
    // [SEQUENCE: 47] Publish domain events
    template<typename Event>
    bool PublishEvent(const Event& event) {
        nlohmann::json event_json = {
            {"event_type", Event::EVENT_TYPE},
            {"event_id", GenerateEventId()},
            {"timestamp", std::chrono::system_clock::now().time_since_epoch().count()},
            {"service_id", GetServiceId()},
            {"data", event.ToJson()}
        };
        
        std::string routing_key = fmt::format("events.{}.{}", 
                                            GetServiceName(), Event::EVENT_TYPE);
        
        return message_queue_->Publish("service.events", routing_key, event_json.dump());
    }
    
    // [SEQUENCE: 48] Subscribe to events from other services
    template<typename Event>
    void SubscribeToEvent(std::function<void(const Event&)> handler) {
        std::string routing_key = fmt::format("events.*.{}", Event::EVENT_TYPE);
        
        message_queue_->Subscribe("service.events", routing_key, 
            [handler](const std::string& message) {
                try {
                    nlohmann::json event_json = nlohmann::json::parse(message);
                    Event event = Event::FromJson(event_json["data"]);
                    handler(event);
                    
                } catch (const std::exception& e) {
                    spdlog::error("Event handling error: {}", e.what());
                }
            });
    }
};

// [SEQUENCE: 49] Example domain events
struct PlayerLevelUpEvent {
    static constexpr const char* EVENT_TYPE = "player.level_up";
    
    uint64_t player_id;
    int old_level;
    int new_level;
    std::chrono::system_clock::time_point timestamp;
    
    nlohmann::json ToJson() const {
        return {
            {"player_id", player_id},
            {"old_level", old_level},
            {"new_level", new_level},
            {"timestamp", timestamp.time_since_epoch().count()}
        };
    }
    
    static PlayerLevelUpEvent FromJson(const nlohmann::json& json) {
        PlayerLevelUpEvent event;
        event.player_id = json["player_id"];
        event.old_level = json["old_level"];
        event.new_level = json["new_level"];
        event.timestamp = std::chrono::system_clock::time_point(
            std::chrono::nanoseconds(json["timestamp"]));
        return event;
    }
};

struct GuildWarStartedEvent {
    static constexpr const char* EVENT_TYPE = "guild.war_started";
    
    uint32_t guild_1_id;
    uint32_t guild_2_id;
    std::string war_zone;
    std::chrono::system_clock::time_point start_time;
    
    nlohmann::json ToJson() const {
        return {
            {"guild_1_id", guild_1_id},
            {"guild_2_id", guild_2_id},
            {"war_zone", war_zone},
            {"start_time", start_time.time_since_epoch().count()}
        };
    }
};
```

---

## ğŸ”§ Distributed Transaction Management

### Saga Pattern Implementation

**`src/microservices/transactions/saga_orchestrator.h` - Implementation:**
```cpp
// [SEQUENCE: 50] Saga pattern for distributed transactions
class SagaOrchestrator {
public:
    struct SagaStep {
        std::string service_name;
        std::string operation;
        nlohmann::json parameters;
        std::string compensation_operation;  // Rollback operation
        bool completed = false;
    };
    
    struct SagaTransaction {
        std::string saga_id;
        std::vector<SagaStep> steps;
        size_t current_step = 0;
        bool failed = false;
        std::string failure_reason;
    };
    
private:
    std::unordered_map<std::string, SagaTransaction> active_sagas_;
    std::shared_ptr<ServiceEventBus> event_bus_;
    std::mutex sagas_mutex_;
    
public:
    // [SEQUENCE: 51] Start a distributed transaction saga
    std::string StartSaga(const std::vector<SagaStep>& steps) {
        std::string saga_id = GenerateSagaId();
        
        SagaTransaction saga;
        saga.saga_id = saga_id;
        saga.steps = steps;
        
        {
            std::lock_guard<std::mutex> lock(sagas_mutex_);
            active_sagas_[saga_id] = saga;
        }
        
        // [SEQUENCE: 52] Execute first step
        ExecuteNextStep(saga_id);
        
        return saga_id;
    }
    
    // [SEQUENCE: 53] Handle step completion events
    void OnStepCompleted(const std::string& saga_id, bool success, const std::string& error = "") {
        std::lock_guard<std::mutex> lock(sagas_mutex_);
        
        auto it = active_sagas_.find(saga_id);
        if (it == active_sagas_.end()) {
            return;
        }
        
        SagaTransaction& saga = it->second;
        
        if (success) {
            // [SEQUENCE: 54] Mark current step as completed
            saga.steps[saga.current_step].completed = true;
            saga.current_step++;
            
            // [SEQUENCE: 55] Check if saga is complete
            if (saga.current_step >= saga.steps.size()) {
                spdlog::info("Saga {} completed successfully", saga_id);
                active_sagas_.erase(it);
                
                // Publish saga completion event
                PublishSagaCompletedEvent(saga_id);
            } else {
                // Execute next step
                ExecuteNextStep(saga_id);
            }
            
        } else {
            // [SEQUENCE: 56] Step failed, start compensation
            saga.failed = true;
            saga.failure_reason = error;
            
            spdlog::warn("Saga {} step {} failed: {}", saga_id, saga.current_step, error);
            StartCompensation(saga_id);
        }
    }
    
private:
    // [SEQUENCE: 57] Execute the next step in the saga
    void ExecuteNextStep(const std::string& saga_id) {
        auto it = active_sagas_.find(saga_id);
        if (it == active_sagas_.end()) {
            return;
        }
        
        const SagaTransaction& saga = it->second;
        const SagaStep& step = saga.steps[saga.current_step];
        
        // [SEQUENCE: 58] Send operation request to target service
        nlohmann::json request = {
            {"saga_id", saga_id},
            {"operation", step.operation},
            {"parameters", step.parameters}
        };
        
        std::string routing_key = fmt::format("saga.{}.request", step.service_name);
        event_bus_->Publish("saga.operations", routing_key, request.dump());
        
        spdlog::info("Saga {} executing step {}: {} on {}", 
                    saga_id, saga.current_step, step.operation, step.service_name);
    }
    
    // [SEQUENCE: 59] Execute compensation (rollback) operations
    void StartCompensation(const std::string& saga_id) {
        auto it = active_sagas_.find(saga_id);
        if (it == active_sagas_.end()) {
            return;
        }
        
        SagaTransaction& saga = it->second;
        
        // [SEQUENCE: 60] Compensate completed steps in reverse order
        for (int i = saga.current_step - 1; i >= 0; i--) {
            const SagaStep& step = saga.steps[i];
            
            if (step.completed && !step.compensation_operation.empty()) {
                nlohmann::json compensation_request = {
                    {"saga_id", saga_id},
                    {"operation", step.compensation_operation},
                    {"parameters", step.parameters}
                };
                
                std::string routing_key = fmt::format("saga.{}.compensation", step.service_name);
                event_bus_->Publish("saga.operations", routing_key, compensation_request.dump());
                
                spdlog::info("Saga {} compensating step {}: {} on {}", 
                            saga_id, i, step.compensation_operation, step.service_name);
            }
        }
        
        // Remove failed saga
        active_sagas_.erase(it);
        PublishSagaFailedEvent(saga_id);
    }
};

// [SEQUENCE: 61] Example: Player guild transfer saga
class PlayerGuildTransferSaga {
public:
    static std::vector<SagaOrchestrator::SagaStep> CreateTransferSteps(
        uint64_t player_id, uint32_t from_guild_id, uint32_t to_guild_id) {
        
        return {
            // Step 1: Validate player can leave current guild
            {
                .service_name = "guild-service",
                .operation = "validate_leave",
                .parameters = {{"player_id", player_id}, {"guild_id", from_guild_id}},
                .compensation_operation = ""  // No compensation needed for validation
            },
            
            // Step 2: Validate player can join target guild
            {
                .service_name = "guild-service", 
                .operation = "validate_join",
                .parameters = {{"player_id", player_id}, {"guild_id", to_guild_id}},
                .compensation_operation = ""
            },
            
            // Step 3: Remove player from current guild
            {
                .service_name = "guild-service",
                .operation = "remove_member",
                .parameters = {{"player_id", player_id}, {"guild_id", from_guild_id}},
                .compensation_operation = "add_member"  // Re-add if later steps fail
            },
            
            // Step 4: Add player to new guild
            {
                .service_name = "guild-service",
                .operation = "add_member", 
                .parameters = {{"player_id", player_id}, {"guild_id", to_guild_id}},
                .compensation_operation = "remove_member"
            },
            
            // Step 5: Update player record
            {
                .service_name = "player-service",
                .operation = "update_guild",
                .parameters = {{"player_id", player_id}, {"guild_id", to_guild_id}},
                .compensation_operation = "update_guild"  // Restore old guild ID
            }
        };
    }
};
```

---

## ğŸ“Š Performance Monitoring & Observability

### Distributed Tracing

**OpenTelemetry Integration:**
```cpp
// [SEQUENCE: 62] Distributed tracing for microservices
#include <opentelemetry/trace/provider.h>
#include <opentelemetry/exporters/jaeger/jaeger_exporter.h>

class DistributedTracing {
private:
    std::shared_ptr<opentelemetry::trace::Tracer> tracer_;
    
public:
    DistributedTracing(const std::string& service_name) {
        // [SEQUENCE: 63] Initialize OpenTelemetry with Jaeger
        auto exporter = std::make_unique<opentelemetry::exporter::jaeger::JaegerExporter>(
            opentelemetry::exporter::jaeger::JaegerExporterOptions{
                .endpoint = "http://jaeger:14268/api/traces"
            }
        );
        
        auto processor = std::make_shared<opentelemetry::sdk::trace::SimpleSpanProcessor>(
            std::move(exporter)
        );
        
        auto provider = std::make_shared<opentelemetry::sdk::trace::TracerProvider>(processor);
        opentelemetry::trace::Provider::SetTracerProvider(provider);
        
        tracer_ = provider->GetTracer(service_name);
    }
    
    // [SEQUENCE: 64] Trace inter-service calls
    template<typename Func>
    auto TraceServiceCall(const std::string& operation_name, 
                         const std::string& target_service,
                         Func&& func) -> decltype(func()) {
        
        auto span = tracer_->StartSpan(operation_name);
        span->SetAttribute("service.name", target_service);
        span->SetAttribute("span.kind", "client");
        
        try {
            auto result = func();
            span->SetStatus(opentelemetry::trace::StatusCode::kOk);
            return result;
            
        } catch (const std::exception& e) {
            span->SetStatus(opentelemetry::trace::StatusCode::kError, e.what());
            span->SetAttribute("error", true);
            span->SetAttribute("error.message", e.what());
            throw;
            
        } finally {
            span->End();
        }
    }
};
```

---

## ğŸ“ˆ Migration Strategy

### Strangler Fig Pattern

**Gradual Migration from Monolith:**
```cpp
// [SEQUENCE: 65] Strangler fig pattern for gradual migration
class MigrationRouter {
private:
    enum class RoutingStrategy {
        MONOLITH_ONLY,      // Route to legacy monolith
        MICROSERVICE_ONLY,  // Route to new microservice
        CANARY,            // Route percentage to microservice
        FEATURE_FLAG       // Route based on feature flags
    };
    
    struct RoutingRule {
        std::string path_pattern;
        RoutingStrategy strategy;
        int microservice_percentage = 0;  // For canary releases
        std::string feature_flag;         // For feature flag routing
    };
    
    std::vector<RoutingRule> routing_rules_;
    std::shared_ptr<FeatureFlagService> feature_flags_;
    
public:
    // [SEQUENCE: 66] Migration phases
    void ConfigureMigrationPhase(MigrationPhase phase) {
        switch (phase) {
            case MigrationPhase::PHASE_1_AUTH_EXTRACTION:
                routing_rules_ = {
                    {"/api/auth/.*", RoutingStrategy::MICROSERVICE_ONLY},
                    {"/api/.*", RoutingStrategy::MONOLITH_ONLY}
                };
                break;
                
            case MigrationPhase::PHASE_2_PLAYER_SERVICE:
                routing_rules_ = {
                    {"/api/auth/.*", RoutingStrategy::MICROSERVICE_ONLY},
                    {"/api/players/.*", RoutingStrategy::CANARY, .microservice_percentage = 10},
                    {"/api/.*", RoutingStrategy::MONOLITH_ONLY}
                };
                break;
                
            case MigrationPhase::PHASE_3_GUILD_SERVICE:
                routing_rules_ = {
                    {"/api/auth/.*", RoutingStrategy::MICROSERVICE_ONLY},
                    {"/api/players/.*", RoutingStrategy::MICROSERVICE_ONLY},
                    {"/api/guilds/.*", RoutingStrategy::FEATURE_FLAG, .feature_flag = "enable_guild_service"},
                    {"/api/.*", RoutingStrategy::MONOLITH_ONLY}
                };
                break;
        }
    }
};
```

---

## ğŸ¯ Best Practices Summary

### 1. Service Boundaries
```cpp
// âœ… Good: Clear domain boundaries
class PlayerService {  // Owns player data and operations
    void UpdatePlayerStats();
    void ManageInventory();
};

class GuildService {   // Owns guild data and operations  
    void ManageGuildMembers();
    void HandleGuildWars();
};

// âŒ Avoid: Mixed responsibilities
class GameService {    // Too broad, unclear boundaries
    void UpdatePlayer();
    void HandleGuild();
    void ProcessWorld();  // Should be separate services
};
```

### 2. Data Consistency
```cpp
// âœ… Good: Eventual consistency with compensation
void TransferPlayer(uint64_t player_id, uint32_t to_guild_id) {
    auto saga_steps = PlayerGuildTransferSaga::CreateTransferSteps(player_id, to_guild_id);
    saga_orchestrator_->StartSaga(saga_steps);  // Handles rollback if needed
}

// âŒ Avoid: Distributed ACID transactions
void TransferPlayerBad(uint64_t player_id, uint32_t to_guild_id) {
    // This will be slow and fragile across services
    auto transaction = distributed_transaction_manager_->BeginTransaction();
    // ... multiple service calls in single transaction
}
```

### 3. Communication Patterns
```cpp
// âœ… Good: Async events for non-critical operations
void OnPlayerLevelUp(uint64_t player_id, int new_level) {
    // Synchronous: Update player record
    player_repository_->UpdateLevel(player_id, new_level);
    
    // Asynchronous: Notify other services
    event_bus_->PublishEvent(PlayerLevelUpEvent{player_id, new_level});
}

// âŒ Avoid: Synchronous calls for non-critical operations
void OnPlayerLevelUpBad(uint64_t player_id, int new_level) {
    player_repository_->UpdateLevel(player_id, new_level);
    achievement_service_->CheckAchievements(player_id);  // Blocking call
    analytics_service_->RecordLevelUp(player_id);        // Blocking call
    // If any service is down, entire operation fails
}
```

---

## ğŸ”— Integration Points

This guide builds upon:
- **message_queue_systems.md**: Event-driven communication between services
- **nosql_integration_guide.md**: Database per service pattern
- **advanced_cpp_features.md**: Modern C++ patterns for service implementation

**Next Implementation Steps:**
1. Extract Authentication Service first (lowest risk)
2. Implement API Gateway with basic routing
3. Add Circuit Breakers for resilience
4. Gradually migrate other services using Strangler Fig pattern

---

*ğŸ’¡ Key Insight: Microservices aren't just about breaking up code - they're about organizational scalability. Each service should be owned by a small team (2-8 people) and have clear business boundaries. Start with the monolith, identify natural service boundaries, and extract services incrementally rather than attempting a big-bang rewrite.*

---

## ğŸ”¥ í”í•œ ì‹¤ìˆ˜ì™€ í•´ê²°ë°©ë²•

### 1. ë„ˆë¬´ ì‘ì€ ì„œë¹„ìŠ¤ ë¶„í• 

#### [SEQUENCE: 1] ëª¨ë“  ê¸°ëŠ¥ì„ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ë¡œ
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ë„ˆë¬´ ì„¸ë¶„í™”ëœ ì„œë¹„ìŠ¤
class HealthPotionService { // ë‹¨ì¼ ê¸°ëŠ¥ ì„œë¹„ìŠ¤
    void UseHealthPotion(uint64_t player_id);
};

class ManaPotionService {   // ë˜ ë‹¤ë¥¸ ë‹¨ì¼ ê¸°ëŠ¥
    void UseManaPotion(uint64_t player_id);
};
// ê´€ë¦¬ ë³µì¡ë„ í­ë°œ!

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ë„ë©”ì¸ ê²½ê³„ë¡œ ë¶„í• 
class InventoryService {    // ì¸ë²¤í† ë¦¬ ê´€ë ¨ ëª¨ë“  ê¸°ëŠ¥
    void UseItem(uint64_t player_id, uint32_t item_id);
    void AddItem(uint64_t player_id, uint32_t item_id, int quantity);
    void RemoveItem(uint64_t player_id, uint32_t item_id, int quantity);
};
```

### 2. ë¶„ì‚° íŠ¸ëœì­ì…˜ ì˜¤ìš©

#### [SEQUENCE: 2] ëª¨ë“  ì‘ì—…ì— ë¶„ì‚° íŠ¸ëœì­ì…˜ ì ìš©
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ë‹¨ìˆœ ì¡°íšŒì—ë„ íŠ¸ëœì­ì…˜
void GetPlayerInfo(uint64_t player_id) {
    auto transaction = StartDistributedTransaction();
    auto player = player_service->GetPlayer(player_id);
    auto guild = guild_service->GetGuild(player.guild_id);
    transaction->Commit();  // ë¶ˆí•„ìš”í•œ ì˜¤ë²„í—¤ë“œ
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: í•„ìš”í•œ ê²½ìš°ì—ë§Œ Saga íŒ¨í„´
void GetPlayerInfo(uint64_t player_id) {
    // ë‹¨ìˆœ ì¡°íšŒëŠ” ë¹„ë™ê¸°ë¡œ
    auto player = player_service->GetPlayer(player_id);
    auto guild = guild_service->GetGuild(player.guild_id);
}

void TransferGuildLeadership(uint64_t from_id, uint64_t to_id) {
    // ì¤‘ìš”í•œ ì‘ì—…ì€ Sagaë¡œ
    saga_orchestrator->StartSaga(GuildLeadershipTransferSaga::Create(from_id, to_id));
}
```

### 3. ì„œë¹„ìŠ¤ ê°„ ë™ê¸° í˜¸ì¶œ ë‚¨ìš©

#### [SEQUENCE: 3] ëª¨ë“  í†µì‹ ì„ ë™ê¸° HTTPë¡œ
```cpp
// âŒ ì˜ëª»ëœ ì˜ˆ: ì²´ì¸ ë™ê¸° í˜¸ì¶œ
void ProcessPlayerAction(uint64_t player_id) {
    auto player = player_service->GetPlayer(player_id);  // HTTP ë™ê¸°
    auto stats = stats_service->GetStats(player_id);    // HTTP ë™ê¸°
    auto items = inventory_service->GetItems(player_id); // HTTP ë™ê¸°
    // ì´ 300ms+ ë ˆì´í„´ì‹œ!
}

// âœ… ì˜¬ë°”ë¥¸ ì˜ˆ: ë¹„ë™ê¸° + ì´ë²¤íŠ¸ ê¸°ë°˜
void ProcessPlayerAction(uint64_t player_id) {
    // í•„ìˆ˜ ë°ì´í„°ë§Œ ë™ê¸°
    auto player = player_service->GetPlayer(player_id);
    
    // ë‚˜ë¨¸ì§€ëŠ” ì´ë²¤íŠ¸ë¡œ
    event_bus->PublishEvent(PlayerActionEvent{player_id, action});
    // ë‹¤ë¥¸ ì„œë¹„ìŠ¤ê°€ ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬
}
```

## ì‹¤ìŠµ í”„ë¡œì íŠ¸

### í”„ë¡œì íŠ¸ 1: ì¸ì¦ ì„œë¹„ìŠ¤ ì¶”ì¶œ (ê¸°ì´ˆ)
**ëª©í‘œ**: ëª¨ë†€ë¦¬ìŠ¤ì—ì„œ ì¸ì¦ ë¡œì§ ë¶„ë¦¬

**êµ¬í˜„ ì‚¬í•­**:
- JWT ê¸°ë°˜ ì¸ì¦
- ì„¸ì…˜ ê´€ë¦¬
- ì‚¬ìš©ì ë“±ë¡/ë¡œê·¸ì¸
- API Gateway í†µí•©

**í•™ìŠµ í¬ì¸íŠ¸**:
- ì„œë¹„ìŠ¤ ê²½ê³„ ì„¤ì •
- RESTful API ì„¤ê³„
- ìƒíƒœë¹„ì €ì¥ ì„¤ê³„

### í”„ë¡œì íŠ¸ 2: API Gateway êµ¬í˜„ (ì¤‘ê¸‰)
**ëª©í‘œ**: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì§„ì…ì  êµ¬ì¶•

**êµ¬í˜„ ì‚¬í•­**:
- ìš”ì²­ ë¼ìš°íŒ…
- ë¡œë“œ ë°¸ëŸ°ì‹±
- ì¸ì¦/ì¸ê°€
- ì†ë„ ì œí•œ

**í•™ìŠµ í¬ì¸íŠ¸**:
- Boost.Beast HTTP
- ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬
- Circuit Breaker

### í”„ë¡œì íŠ¸ 3: ë¶„ì‚° íŠ¸ëœì­ì…˜ (ê³ ê¸‰)
**ëª©í‘œ**: Saga íŒ¨í„´ êµ¬í˜„

**êµ¬í˜„ ì‚¬í•­**:
- Saga Orchestrator
- ë³´ìƒ íŠ¸ëœì­ì…˜
- ì´ë²¤íŠ¸ ì†Œì‹±
- ìƒíƒœ ì¶”ì 

**í•™ìŠµ í¬ì¸íŠ¸**:
- ë¶„ì‚° íŠ¸ëœì­ì…˜ ì´ë¡ 
- ìµœì¢… ì¼ê´€ì„±
- ì´ë²¤íŠ¸ ê¸°ë°˜ ë³´ìƒ

## í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ì´ˆ ë ˆë²¨ âœ…
- [ ] ëª¨ë†€ë¦¬ìŠ¤ vs ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤
- [ ] RESTful API ì„¤ê³„ ì›ì¹™
- [ ] ì„œë¹„ìŠ¤ ê²½ê³„ ì •ì˜
- [ ] API Gateway ê°œë…

### ì¤‘ê¸‰ ë ˆë²¨ ğŸ“š
- [ ] ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬ (Consul)
- [ ] ë¡œë“œ ë°¸ëŸ°ì‹± ì „ëµ
- [ ] Circuit Breaker íŒ¨í„´
- [ ] ë¹„ë™ê¸° í†µì‹ 

### ê³ ê¸‰ ë ˆë²¨ ğŸš€
- [ ] Saga íŒ¨í„´
- [ ] CQRS íŒ¨í„´
- [ ] ì´ë²¤íŠ¸ ì†Œì‹±
- [ ] ë¶„ì‚° ì¶”ì 

### ì „ë¬¸ê°€ ë ˆë²¨ ğŸ†
- [ ] Service Mesh (Istio)
- [ ] ì¹´ì˜¤ìŠ¤ ì—”ì§€ë‹ˆì–´ë§
- [ ] Multi-tenancy
- [ ] Edge Computing

## ì¶”ê°€ í•™ìŠµ ìë£Œ

### ì¶”ì²œ ë„ì„œ
- "Building Microservices" - Sam Newman
- "Microservices Patterns" - Chris Richardson
- "Release It!" - Michael Nygard
- "Domain-Driven Design" - Eric Evans

### ì˜¨ë¼ì¸ ë¦¬ì†ŒìŠ¤
- [Microservices.io](https://microservices.io/)
- [Martin Fowler's Microservices](https://martinfowler.com/articles/microservices.html)
- [12 Factor App](https://12factor.net/)
- [CNCF Cloud Native Trail Map](https://github.com/cncf/trailmap)

### ì‹¤ìŠµ ë„êµ¬
- Docker & Docker Compose
- Kubernetes (Minikube/K3s)
- Consul/etcd (ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬)
- Jaeger (ë¶„ì‚° ì¶”ì )

### í…ŒìŠ¤íŠ¸ ë„êµ¬
```bash
# ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
curl -X GET http://localhost:8080/api/players/123

# ë¡œë“œ í…ŒìŠ¤íŠ¸
ab -n 10000 -c 100 http://localhost:8080/api/health

# íšŒë¡œ ì°¨ë‹¨ê¸° í…ŒìŠ¤íŠ¸
for i in {1..20}; do curl -X GET http://localhost:8080/api/fail; done
```

---

*ğŸš€ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ëŠ” ì€íƒ„í™˜ì´ ì•„ë‹™ë‹ˆë‹¤. ëª¨ë†€ë¦¬ìŠ¤ê°€ ì í•©í•œ ê²½ìš°ë„ ë§ìŠµë‹ˆë‹¤. íŒ€ì˜ í¬ê¸°, ì„œë¹„ìŠ¤ì˜ ë³µì¡ë„, ë…ë¦½ì ì¸ ë°°í¬ í•„ìš”ì„±ì„ ê³ ë ¤í•˜ì—¬ ì•„í‚¤í…ì²˜ë¥¼ ì„ íƒí•˜ì„¸ìš”. ì‹œì‘ì€ ë‹¨ìˆœí•˜ê²Œ, í•„ìš”ì— ë”°ë¼ ì§„í™”ì‹œí‚¤ì„¸ìš”!*